<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helkay</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.helkay.me/"/>
  <updated>2017-11-10T03:52:57.000Z</updated>
  <id>http://blog.helkay.me/</id>
  
  <author>
    <name>Helkay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机基础之位运算</title>
    <link href="http://blog.helkay.me/2017/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://blog.helkay.me/2017/10/计算机基础之位运算/</id>
    <published>2017-10-24T16:00:00.000Z</published>
    <updated>2017-11-10T03:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><strong>机器数</strong></p>
<p>一个数在计算机中的二进制表示形式,叫做这个数的机器数。</p>
<p>机器数是带符号的,在计算机用一个数的 <strong><em>最高位</em></strong> 存放符号, <strong><em>正数为0, 负数为1</em></strong>.</p>
<p>比如,十进制中的数 +3,计算机字长为8位,转换成二进制就是00000011.如果是 -3,就是 10000011 .</p>
<p>那么，这里的 00000011 和 10000011 就是机器数。</p>
<p><strong>原码</strong></p>
<p>原码就是 <strong><em>符号位</em></strong> 加上真值的绝对值</p>
<pre><code>[+1]原 = 0000 0001

[-1]原 = 1000 0001
</code></pre><p><strong>反码</strong></p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上,符号位不变,其余各个位取反.</p>
<pre><code>[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反
</code></pre><p><strong>补码</strong></p>
<p>正数的补码就是其本身.</p>
<p>负数的补码是在其原码的基础上,符号位不变,其余各位取反,最后+1. (即在反码的基础上+1)</p>
<pre><code>[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
</code></pre><p><strong>与（&amp;）运算符</strong></p>
<p>两个操作数中位都为1，结果才为1，否则结果为0</p>
<pre><code>4 : 100
7 : 111
a &amp; b = 4 : 100
</code></pre><p><strong>或（|）运算符</strong></p>
<p>两个操作数中位只要有一个为1，那么结果就是1，否则就为0</p>
<pre><code>4 : 100
7 : 111
a | b = 7 : 111
</code></pre><p><strong>非运算符</strong></p>
<p>非运算符用符号“~”表示，其运算规律如下:</p>
<p>如果位为0，结果是1，如果位为1，结果是0</p>
<pre><code>4       : 00000000 00000000 00000000 00000100
~a = -5 : 11111111 11111111 11111111 11111011
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二进制&quot;&gt;&lt;a href=&quot;#二进制&quot; class=&quot;headerlink&quot; title=&quot;二进制&quot;&gt;&lt;/a&gt;二进制&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;机器数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个数在计算机中的二进制表示形式,叫做这个数的机器数。&lt;/p&gt;
&lt;p&gt;机器数
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="计算机基础" scheme="http://blog.helkay.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>spring aop事务</title>
    <link href="http://blog.helkay.me/2017/06/spring%20aop%E4%BA%8B%E5%8A%A1/"/>
    <id>http://blog.helkay.me/2017/06/spring aop事务/</id>
    <published>2017-06-28T16:00:00.000Z</published>
    <updated>2017-06-29T05:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于今天项目配置了spring aop事务发现不生效,检查配置文件如下没有问题</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id=&quot;mysqlTransactionManager&quot;
          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 使用annotation注解方式配置事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;mysqlTransactionManager&quot;/&gt;

    &lt;!-- AOP配置事物 --&gt;
    &lt;tx:advice id=&quot;mysqlTransactionAdvice&quot; transaction-manager=&quot;mysqlTransactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot;/&gt;
            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot;/&gt;
            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot;/&gt;
            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot;/&gt;
            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot;/&gt;
            &lt;tx:method name=&quot;rollBack*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- 配置AOP切面 --&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;mysqlTransactionPointCut&quot;
                      expression=&quot;execution(* com.at.service.impl.*.*(..))&quot;/&gt;
        &lt;aop:advisor pointcut-ref=&quot;mysqlTransactionPointCut&quot;
                     advice-ref=&quot;mysqlTransactionAdvice&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<p>网上查询了下资料,发现是由于mysql数据库存储引擎导致的, MyISAM不支持事务,需要修改成InnoDB</p>
<p><strong>查看</strong></p>
<pre><code class="mysql">show table status;
</code></pre>
<p><strong>修改</strong></p>
<pre><code class="mysql">alter table table_name engine=innodb;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于今天项目配置了spring aop事务发现不生效,检查配置文件如下没有问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;b
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Spring" scheme="http://blog.helkay.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>mysql快速复制数据库</title>
    <link href="http://blog.helkay.me/2017/06/mysql%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://blog.helkay.me/2017/06/mysql快速复制数据库/</id>
    <published>2017-06-19T16:00:00.000Z</published>
    <updated>2017-06-20T03:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>某些时候，为了搭建一个测试环境,需要复制一个已存在的MySQL数据库。</p>
<p><strong>创建表</strong></p>
<pre><code class="bash">CREATE DATABASE dbtest DEFAULT CHARACTER SET utf8 COLLATE UTF8_GENERAL_CI;
</code></pre>
<p><strong>复制数据库</strong></p>
<pre><code class="bash">mysqldump db -u root -ppassword --add-drop-table | mysql dbtest -u root -ppassword
</code></pre>
<p>-ppassword : password为密码 如果秘密中有特殊字符需要转译(字符前加上)不然会报(mysqldump: Got error: 1045: Access denied for user ‘root’@’localhost’ (using password: YES) when trying to connect) </p>
<p><strong>复制到远程另一台MySQL服务器上</strong></p>
<pre><code class="bash">mysqldump db -u root -ppassword --add-drop-table | mysql -h 192.168.1.2  dbtest -u root -ppassword
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某些时候，为了搭建一个测试环境,需要复制一个已存在的MySQL数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;CREATE DATABASE dbtest DEFAULT CHARACTER SET 
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Mysql" scheme="http://blog.helkay.me/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql ip授权</title>
    <link href="http://blog.helkay.me/2017/05/mysql%20ip%E6%8E%88%E6%9D%83/"/>
    <id>http://blog.helkay.me/2017/05/mysql ip授权/</id>
    <published>2017-05-26T16:00:00.000Z</published>
    <updated>2017-05-27T03:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="bash">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;username&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;

mysql&gt;FLUSH PRIVILEGES;
</code></pre>
<p><strong>grant语法:</strong></p>
<p>grant 权限名（所有的权限用all） on 库名（<em>全部）.表名（</em>全部） to ‘要授权的用户名’@’%’(%表示所有的IP，可以只些一个IP） identified by “密码”；</p>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;mysql&amp;gt;GRANT ALL PRIVILEGES ON *.* TO &amp;#39;username&amp;#39;@&amp;#39;127.0.0.1&amp;#39; IDENTIFIED BY &amp;#39;password&amp;#39; WITH
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Mysql" scheme="http://blog.helkay.me/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="http://blog.helkay.me/2017/05/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://blog.helkay.me/2017/05/浅拷贝和深拷贝/</id>
    <published>2017-05-22T16:00:00.000Z</published>
    <updated>2017-05-23T09:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="设计模式" scheme="http://blog.helkay.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://blog.helkay.me/2017/05/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.helkay.me/2017/05/原型模式/</id>
    <published>2017-05-22T16:00:00.000Z</published>
    <updated>2017-07-04T03:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>原型模式属于创建型模式的一种,其精髓就在于<strong><em>复制</em></strong>一个存在的实例,而不是去新建。</p>
<h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p>我们设想一个这样的场景,小明在X宝上购物,选定购买商品后就要去下订单,我们会发现小明购买多次的订单除了购买商品不同,邮寄地址、收件人、联系方式都是一样的,这时候我们就可以使用原型模型来创建订单了。</p>
<div align="center"><br><img src="http://blog.helkay.me/pic/prototype.png" style="width:700px;" alt="图片名称" align="center">
</div>

<p><strong>Prototype:</strong> 实现Cloneable接口(Cloneable就相当于Prototype接口) 重写Object的clone方法,如果不实现Cloneable接口则会抛出CloneNotSupportedException异常</p>
<p><strong>OrderInfo:</strong></p>
<pre><code class="java">public class OrderInfo implements Cloneable {

    private String goodsName;

    private String address;

    private String username;

    private String mobile;

    public String getGoodsName() {
        return goodsName;
    }

    public void setGoodsName(String goodsName) {
        this.goodsName = goodsName;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getMobile() {
        return mobile;
    }

    public void setMobile(String mobile) {
        this.mobile = mobile;
    }

    @Override
    public String toString() {
        return &quot;OrderInfo{&quot; +
                &quot;goodsName=&#39;&quot; + goodsName + &#39;\&#39;&#39; +
                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +
                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +
                &quot;, mobile=&#39;&quot; + mobile + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

    @Override
    public OrderInfo clone() throws CloneNotSupportedException {
        return (OrderInfo) super.clone();
    }

}
</code></pre>
<p><strong>Test</strong></p>
<pre><code class="java">public class Test {

    public static void main(String[] args) throws CloneNotSupportedException {

        OrderInfo orderInfo = new OrderInfo();
        orderInfo.setAddress(&quot;上海市XXXXX&quot;);
        orderInfo.setMobile(&quot;138XXXXXXXX&quot;);
        orderInfo.setUsername(&quot;小明&quot;);

        orderInfo.setGoodsName(&quot;零食&quot;);

        OrderInfo orderInfo1 = orderInfo.clone();
        orderInfo1.setGoodsName(&quot;衣服&quot;);

        System.out.println(orderInfo.toString());
        System.out.println(orderInfo1.toString());

    }
}
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="bash">OrderInfo{goodsName=&#39;零食&#39;, address=&#39;上海市XXXXX&#39;, username=&#39;小明&#39;, mobile=&#39;138XXXXXXXX&#39;}
OrderInfo{goodsName=&#39;衣服&#39;, address=&#39;上海市XXXXX&#39;, username=&#39;小明&#39;, mobile=&#39;138XXXXXXXX&#39;}
</code></pre>
<p><strong><em>值得一提的是Object类的clone方法为浅拷贝,关于如何实现深拷贝就是对clone方法进行改造了,有关浅拷贝和深拷贝的相关信息请看下面这篇:<a href="http://helkay.me/2017/05/浅拷贝和深拷贝/" target="_blank" rel="external">浅拷贝和深拷贝</a></em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;原型模式属于创建型模式的一种,其精髓就在于&lt;strong&gt;&lt;em&gt;复制&lt;/em&gt;&lt;/strong&gt;一个存在的实例,而不是去新建。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="设计模式" scheme="http://blog.helkay.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://blog.helkay.me/2017/05/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.helkay.me/2017/05/建造者模式/</id>
    <published>2017-05-18T16:00:00.000Z</published>
    <updated>2017-07-04T03:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>建造模式是对象的创建模式。建造模式可以将一个产品的内部表象与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p>
<p>本模式涉及到四个角色，它们分别是：</p>
<ul>
<li>产品（Product）角色：</li>
<li>抽象建造者（Builder）角色</li>
<li>具体建造者（ConcreteBuilder）角色</li>
<li>导演者（Director）角色</li>
</ul>
<div align="center"><br><img src="http://blog.helkay.me/pic/builder.png" style="width:700px;" alt="图片名称" align="center">
</div>


<h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p><strong>Product</strong></p>
<pre><code class="java">public class Product {

    private String name;

    private Double price;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }
}
</code></pre>
<p><strong>Builder</strong></p>
<pre><code class="java">public interface Builder {

    public void createName();

    public void createPrice();

    public Product returnProduct();

}
</code></pre>
<p><strong>ConcreteBuilder</strong></p>
<pre><code class="java">public class ConcreteBuilder implements Builder {

    private Product product = new Product();

    @Override
    public void createName() {
        product.setName(&quot;productName&quot;);
    }

    @Override
    public void createPrice() {
        product.setPrice(new Double(100));
    }

    @Override
    public Product returnProduct() {
        return product;
    }
}
</code></pre>
<p><strong> Director</strong></p>
<pre><code class="java">public class Director {

    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    public void construct(){
        builder.createName();
        builder.createPrice();
    }
}
</code></pre>
<p><strong>Test</strong></p>
<pre><code class="java">public class Test {

    public static void main(String[] args) {
        Builder builder = new ConcreteBuilder();
        Director director = new Director(builder);
        director.construct();
        Product product = builder.returnProduct();
        System.out.println(product.getName());
        System.out.println(product.getPrice());
    }

}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;建造模式是对象的创建模式。建造模式可以将一个产品的内部表象与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="设计模式" scheme="http://blog.helkay.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令 - chmod</title>
    <link href="http://blog.helkay.me/2017/05/Linux%E5%91%BD%E4%BB%A4%20-%20chmod/"/>
    <id>http://blog.helkay.me/2017/05/Linux命令 - chmod/</id>
    <published>2017-05-18T16:00:00.000Z</published>
    <updated>2017-05-19T07:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h3><pre><code class="bash">chmod [-cfvR] [--help] [--version] mode file...
</code></pre>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h3><p><strong>mode:</strong> 权限设定字串</p>
<pre><code class="bash">[ugoa...][[+-=][rwxX]...][,...]
</code></pre>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li><ul>
<li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
</ul>
</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="bash">#将文件 file1.txt 设为所有人皆可读取
chmod ugo+r file1.txt

#将目前目录下的所有文件与子目录皆设为任何人可读取 :
chmod -R a+r *
</code></pre>
<p><strong>此外chmod也可以用数字来表示权限如 :</strong></p>
<pre><code class="bash">chmod 777 file
</code></pre>
<p>语法为：</p>
<pre><code class="bash">chmod abc file
</code></pre>
<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。
r=4，w=2，x=1</p>
<p><strong><em>若用chmod 4755 filename可使此程序具有root的权限</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;功能：&quot;&gt;&lt;a href=&quot;#功能：&quot; class=&quot;headerlink&quot; title=&quot;功能：&quot;&gt;&lt;/a&gt;功能：&lt;/h3&gt;&lt;p&gt;文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。&lt;/p&gt;
&lt;h3 id=&quot;语法
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Linux" scheme="http://blog.helkay.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令 - find</title>
    <link href="http://blog.helkay.me/2017/05/Linux%E5%91%BD%E4%BB%A4%20-%20find/"/>
    <id>http://blog.helkay.me/2017/05/Linux命令 - find/</id>
    <published>2017-05-14T16:00:00.000Z</published>
    <updated>2017-05-16T04:50:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>在指定目录下查找文件,如果不设置任何参数,则find命令将在当前目录下查找子目录与文件</p>
<h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><pre><code class="bash">find pathname -options [-print -exec -ok ...]
</code></pre>
<p><strong>pathname:</strong>  find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 </p>
<p><strong>-print:</strong>  find命令将匹配的文件输出到标准输出。 </p>
<p><strong>-exec:</strong>  find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {  } \;，注意{   }和\；之间的空格。 </p>
<p><strong>-ok:</strong>  和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执</p>
<h3 id="命令选项："><a href="#命令选项：" class="headerlink" title="命令选项："></a>命令选项：</h3><p><strong>-name :</strong>   按照文件名查找文件。</p>
<pre><code class="bash">find . -name filename

#查找当前目录包括子目录及子目录里的目录里以.txt结尾的文件
find . -name &#39;*.txt&#39;
</code></pre>
<p><strong>-perm :</strong>   按照文件权限来查找文件。</p>
<pre><code class="bash">find . -perm 755
</code></pre>
<p>顺带一提  在linux下权限数字rwx  r=4，w=2，x=1 </p>
<p><strong>-prune :</strong>  使用这一选项可以使find命令不在当前指定的目录中查找,如果同时使用-depth选项，那么-prune将被find命令忽略。</p>
<pre><code class="bash">#查找当前目录下的子目录及子目录中 名为dir文件夹中以.txt结尾的所有文件
find . -path &#39;*dir*&#39; -name &#39;*.txt&#39;

#只查找当前目录下 以.txt结尾的文件
find . -depth 1 -name &#39;*.txt&#39;
find . -maxdepth 1 -name &#39;.txt&#39;

#查找当前目录下名为dir的子目录中所有以.txt结尾的文件
find . -path &#39;./dir*&#39; -name &#39;*.txt&#39;

#查找dir目录中除了子目录dir0下其他子目录中以.txtx结尾的所有文件
find . -path &#39;./dir0&#39; -prune -o -name &#39;*.txt&#39; -print
</code></pre>
<p><strong>-user :</strong>   按照文件属主来查找文件。</p>
<pre><code class="bash">find . -user Helkay
</code></pre>
<p><strong>-group :</strong>  按照文件所属的组来查找文件。</p>
<pre><code class="bash">find . -group staff
</code></pre>
<p><strong>-mtime -n +n :</strong>  按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内,+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。</p>
<p><strong>-nogroup :</strong>  查找无有效所属组的文件,即该文件所属的组在/etc/groups中不存在。</p>
<pre><code class="bash">#列出/home内不属于本地组的文件或目录
find /home -nogroup
</code></pre>
<p><strong>-nouser :</strong>   查找无有效属主的文件,即该文件的属主在/etc/passwd中不存在。</p>
<pre><code class="bash">#列出/home内不属于本地用户的文件或目录  
find /home -nouser
</code></pre>
<p><strong>-newer file1 ! file2 :</strong>  查找更改时间比文件file1新但比文件file2旧的文件。</p>
<pre><code class="bash">find /home -newer tmp.txt ! tmp1.txt
</code></pre>
<p><strong>-type :</strong>  查找某一类型的文件,诸如：</p>
<ul>
<li>b - 块设备文件。</li>
<li>d - 目录。</li>
<li>c - 字符设备文件。</li>
<li>p - 管道文件。</li>
<li>l - 符号链接文件。</li>
<li>f - 普通文件。</li>
</ul>
<pre><code class="bash">find . -type d
</code></pre>
<p><strong>-size n：[c,k] :</strong> 查找文件长度为n块的文件,带有c时表示文件长度以字节计。-depth：在查找文件时,首先查找当前目录中的文件,然后再在其子目录中查找。</p>
<pre><code class="bash">#查找当前目录下(包括子目录)文件大于100k 小于200k 的文件
find . -size +100k -size -200k
</code></pre>
<p><strong>-fstype :</strong> 查找位于某一类型文件系统中的文件,这些文件系统类型通常可以在配置文件/etc/fstab中找到,该配置文件中包含了本系统中有关文件系统的信息。</p>
<pre><code class="bash">find / -fstype ext2
</code></pre>
<p><strong>-mount :</strong> 在查找文件时不跨越文件系统mount点。</p>
<p><strong>-follow :</strong> 如果find命令遇到符号链接文件,就跟踪至链接所指向的文件。</p>
<p><strong>-cpio :</strong>对匹配的文件使用cpio命令,将这些文件备份到磁带设备中。</p>
<p>另外,下面三个的区别:</p>
<p><strong>-amin n :</strong>  查找系统中最后N分钟访问的文件</p>
<p><strong>-atime n :</strong> 查找系统中最后n*24小时访问的文件</p>
<p><strong>-cmin n :</strong>  查找系统中最后N分钟被改变文件状态的文件</p>
<p><strong>-ctime n :</strong> 查找系统中最后n*24小时被改变文件状态的文件</p>
<p><strong>-mmin n :</strong>  查找系统中最后N分钟被改变文件数据的文件</p>
<p><strong>-mtime n :</strong> 查找系统中最后n*24小时被改变文件数据的文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;功能：&quot;&gt;&lt;a href=&quot;#功能：&quot; class=&quot;headerlink&quot; title=&quot;功能：&quot;&gt;&lt;/a&gt;功能：&lt;/h3&gt;&lt;p&gt;在指定目录下查找文件,如果不设置任何参数,则find命令将在当前目录下查找子目录与文件&lt;/p&gt;
&lt;h3 id=&quot;命令格式：&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Linux" scheme="http://blog.helkay.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令 - cat</title>
    <link href="http://blog.helkay.me/2017/05/Linux%E5%91%BD%E4%BB%A4%20-%20cat/"/>
    <id>http://blog.helkay.me/2017/05/Linux命令 - cat/</id>
    <published>2017-05-14T16:00:00.000Z</published>
    <updated>2017-05-15T11:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li>显示文件的内容</li>
</ul>
<pre><code class="bash">cat filename
</code></pre>
<ul>
<li>创建文件</li>
</ul>
<pre><code class="bash">cat &gt; filename
</code></pre>
<p>值得一提的是执行这个命令之后会进入一个输入模式,只会保存回车后的内容</p>
<ul>
<li>合并内容</li>
</ul>
<pre><code class="bash">cat file1 file2 &gt; file
</code></pre>
<p>将 file1 和 file2 的内容合并到 file 中,按照从左至右的先后顺序,如果 file 已存在则会覆盖 file中的内容</p>
<h3 id="使用权限："><a href="#使用权限：" class="headerlink" title="使用权限："></a>使用权限：</h3><p>所有使用者</p>
<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><strong>-n :</strong> 输出每行的行数编号</p>
<pre><code class="bash">$cat -n test 
1    This is the 1th line
2    
3    This is the 3th line
4    
5    This is the 5th line
</code></pre>
<p><strong>-b :</strong> 和 -n 差不多,只是不输出空白行</p>
<pre><code class="bash">$cat -b test
1    This is the 1th line

2    This is the 3th line

3    This is the 5th line
</code></pre>
<p><strong>-s :</strong> 将连续两行以上的空白行,用一行空白行来代替</p>
<p>原文件内容(数字为行号)如下</p>
<pre><code>  1 This is the 1th line
  2 
  3 
  4 This is the 4th line
  5 
  6 
  7 
  8 
  9 This is the 9th line
</code></pre><p>使用-s输出结果如下</p>
<pre><code class="bash">$cat -s test 
This is the 1th line

This is the 4th line

This is the 9th line
</code></pre>
<p><strong>-v :</strong> 使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外</p>
<p><strong>-E :</strong> 或 –show-ends : 在每行结束处显示 $</p>
<p><strong>-T :</strong> 或 –show-tabs: 将 TAB 字符显示为 ^I</p>
<p><strong>-A :</strong> 等价于 -vET</p>
<p><strong>-e :</strong> 等价于”-vE”选项</p>
<p><strong>-t :</strong> 等价于”-vT”选项</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;功能：&quot;&gt;&lt;a href=&quot;#功能：&quot; class=&quot;headerlink&quot; title=&quot;功能：&quot;&gt;&lt;/a&gt;功能：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;显示文件的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;cat filename
&lt;/co
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Linux" scheme="http://blog.helkay.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://blog.helkay.me/2017/05/Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.helkay.me/2017/05/Git命令/</id>
    <published>2017-05-11T16:00:00.000Z</published>
    <updated>2017-05-12T10:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-user-name-uesremail设置"><a href="#Git-user-name-uesremail设置" class="headerlink" title="Git user.name uesremail设置"></a>Git user.name uesremail设置</h2><pre><code class="bash">#全局
git config --global user.name  &quot;your_name&quot;
git config --global user.emial &quot;your_email&quot;

#局部
git config user.name  &quot;your_name&quot;
git config user.emial &quot;your_email&quot;

#取消
git config --unset --global user.name
git config --unset --global user.email
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git-user-name-uesremail设置&quot;&gt;&lt;a href=&quot;#Git-user-name-uesremail设置&quot; class=&quot;headerlink&quot; title=&quot;Git user.name uesremail设置&quot;&gt;&lt;/a&gt;Git user.na
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Git" scheme="http://blog.helkay.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux工具与命令</title>
    <link href="http://blog.helkay.me/menu/Linux%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.helkay.me/menu/Linux工具与命令/</id>
    <published>2017-05-11T16:00:00.000Z</published>
    <updated>2017-07-04T03:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="http://blog.helkay.me/2017/05/Git命令">Git命令</a></li>
</ul>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p><strong>文件管理</strong></p>
<table>
<thead>
<tr>
<th><a href="_cat_">cat</a></th>
<th>chattr</th>
<th>chgrp</th>
<th><a href="_chmod_">chmod</a>               </th>
</tr>
</thead>
<tbody>
<tr>
<td>chown</td>
<td>cksum</td>
<td>cmp</td>
<td>diff                </td>
</tr>
<tr>
<td>diffstat</td>
<td>file</td>
<td><a href="_find_">find</a></td>
<td>git                 </td>
</tr>
<tr>
<td>gitview</td>
<td>indent</td>
<td>cut</td>
<td>ln                  </td>
</tr>
<tr>
<td>less</td>
<td>locate</td>
<td>lsattr</td>
<td>mattrib             </td>
</tr>
<tr>
<td>mc</td>
<td>mdel</td>
<td>mdir</td>
<td>mktemp              </td>
</tr>
<tr>
<td>more</td>
<td>mmove</td>
<td>mread</td>
<td>mren                </td>
</tr>
<tr>
<td>mtools</td>
<td>mtoolstest</td>
<td>mv</td>
<td>od                  </td>
</tr>
<tr>
<td>paste</td>
<td>patch</td>
<td>rcp</td>
<td>rm                  </td>
</tr>
<tr>
<td>slocate</td>
<td>split</td>
<td>tee</td>
<td>tmpwatch            </td>
</tr>
<tr>
<td>touch</td>
<td>umask</td>
<td>which</td>
<td>cp                  </td>
</tr>
<tr>
<td>whereis</td>
<td>mcopy</td>
<td>mshowfat</td>
<td>rhmask              </td>
</tr>
<tr>
<td>scp</td>
<td>awk</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>文档编辑</strong></p>
<table>
<thead>
<tr>
<th>col</th>
<th>colrm</th>
<th>comm</th>
<th>csplit              </th>
</tr>
</thead>
<tbody>
<tr>
<td>ed</td>
<td>egrep</td>
<td>ex</td>
<td>fgrep               </td>
</tr>
<tr>
<td>fmt</td>
<td>fold</td>
<td>grep</td>
<td>ispell              </td>
</tr>
<tr>
<td>jed</td>
<td>joe</td>
<td>join</td>
<td>look                </td>
</tr>
<tr>
<td>mtype</td>
<td>pico</td>
<td>rgrep</td>
<td>sed                 </td>
</tr>
<tr>
<td>sort</td>
<td>spell</td>
<td>tr</td>
<td>expr                </td>
</tr>
<tr>
<td>uniq</td>
<td>wc</td>
<td>let</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>文件传输</strong></p>
<table>
<thead>
<tr>
<th>lprm</th>
<th>lpr</th>
<th>lpq</th>
<th>lpd                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>bye</td>
<td>ftp</td>
<td>uuto</td>
<td>uupick              </td>
</tr>
<tr>
<td>uucp</td>
<td>uucico</td>
<td>tftp</td>
<td>ncftp               </td>
</tr>
<tr>
<td>ftpshut</td>
<td>ftpwho</td>
<td>ftpcount</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>磁盘管理</strong></p>
<table>
<thead>
<tr>
<th>cd</th>
<th>df</th>
<th>dirs</th>
<th>du                  </th>
</tr>
</thead>
<tbody>
<tr>
<td>edquota</td>
<td>eject</td>
<td>mcd</td>
<td>mdeltree            </td>
</tr>
<tr>
<td>mdu</td>
<td>mkdir</td>
<td>mlabel</td>
<td>mmd                 </td>
</tr>
<tr>
<td>mrd</td>
<td>mzip</td>
<td>pwd</td>
<td>quota               </td>
</tr>
<tr>
<td>mount</td>
<td>mmount</td>
<td>rmdir</td>
<td>rmt                 </td>
</tr>
<tr>
<td>stat</td>
<td>tree</td>
<td>umount</td>
<td>ls                  </td>
</tr>
<tr>
<td>quotacheck</td>
<td>quotaoff</td>
<td>lndir</td>
<td>repquota            </td>
</tr>
<tr>
<td>quotaon</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>磁盘维护</strong></p>
<table>
<thead>
<tr>
<th>badblocks</th>
<th>cfdisk</th>
<th>dd</th>
<th>e2fsck              </th>
</tr>
</thead>
<tbody>
<tr>
<td>ext2ed</td>
<td>fsck</td>
<td>fsck.minix</td>
<td>fsconf              </td>
</tr>
<tr>
<td>fdformat</td>
<td>hdparm</td>
<td>mformat</td>
<td>mkbootdisk          </td>
</tr>
<tr>
<td>mkdosfs</td>
<td>mke2fs</td>
<td>mkfs.ext2</td>
<td>mkfs.msdos          </td>
</tr>
<tr>
<td>mkinitrd</td>
<td>mkisofs</td>
<td>mkswap</td>
<td>mpartition          </td>
</tr>
<tr>
<td>swapon</td>
<td>symlinks</td>
<td>sync</td>
<td>mbadblocks          </td>
</tr>
<tr>
<td>mkfs.minix</td>
<td>fsck.ext2</td>
<td>fdisk</td>
<td>losetup             </td>
</tr>
<tr>
<td>mkfs</td>
<td>sfdisk</td>
<td>swapoff</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>网络通讯</strong></p>
<table>
<thead>
<tr>
<th>apachectl</th>
<th>arpwatch</th>
<th>dip</th>
<th>getty               </th>
</tr>
</thead>
<tbody>
<tr>
<td>mingetty</td>
<td>uux</td>
<td>telnet</td>
<td>uulog               </td>
</tr>
<tr>
<td>uustat</td>
<td>ppp-off</td>
<td>netconfig</td>
<td>nc                  </td>
</tr>
<tr>
<td>httpd</td>
<td>ifconfig</td>
<td>minicom</td>
<td>mesg                </td>
</tr>
<tr>
<td>dnsconf</td>
<td>wall</td>
<td>netstat</td>
<td>ping                </td>
</tr>
<tr>
<td>pppstats</td>
<td>samba</td>
<td>setserial</td>
<td>talk                </td>
</tr>
<tr>
<td>traceroute</td>
<td>tty</td>
<td>newaliases</td>
<td>uuname              </td>
</tr>
<tr>
<td>netconf</td>
<td>write</td>
<td>statserial</td>
<td>efax                </td>
</tr>
<tr>
<td>pppsetup</td>
<td>tcpdump</td>
<td>ytalk</td>
<td>cu                  </td>
</tr>
<tr>
<td>smbd</td>
<td>testparm</td>
<td>smbclient</td>
<td>shapecfg            </td>
</tr>
</tbody>
</table>
<p><strong>系统管理</strong></p>
<table>
<thead>
<tr>
<th>adduser</th>
<th>chfn</th>
<th>useradd</th>
<th>date                </th>
</tr>
</thead>
<tbody>
<tr>
<td>exit</td>
<td>finger</td>
<td>fwhios</td>
<td>sleep               </td>
</tr>
<tr>
<td>suspend</td>
<td>groupdel</td>
<td>groupmod</td>
<td>halt                </td>
</tr>
<tr>
<td>kill</td>
<td>last</td>
<td>lastb</td>
<td>login               </td>
</tr>
<tr>
<td>logname</td>
<td>logout</td>
<td>ps</td>
<td>nice                </td>
</tr>
<tr>
<td>procinfo</td>
<td>top</td>
<td>pstree</td>
<td>reboot              </td>
</tr>
<tr>
<td>rlogin</td>
<td>rsh</td>
<td>sliplogin</td>
<td>screen              </td>
</tr>
<tr>
<td>shutdown</td>
<td>rwho</td>
<td>sudo</td>
<td>gitps               </td>
</tr>
<tr>
<td>swatch</td>
<td>tload</td>
<td>logrotate</td>
<td>uname               </td>
</tr>
<tr>
<td>chsh</td>
<td>userconf</td>
<td>userdel</td>
<td>usermod             </td>
</tr>
<tr>
<td>vlock</td>
<td>who</td>
<td>whoami</td>
<td>whois               </td>
</tr>
<tr>
<td>newgrp</td>
<td>renice</td>
<td>su</td>
<td>skill               </td>
</tr>
<tr>
<td>w</td>
<td>id</td>
<td>free</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>系统设置</strong></p>
<table>
<thead>
<tr>
<th>reset</th>
<th>clear</th>
<th>alias</th>
<th>dircolors           </th>
</tr>
</thead>
<tbody>
<tr>
<td>aumix</td>
<td>bind</td>
<td>chroot</td>
<td>clock               </td>
</tr>
<tr>
<td>crontab</td>
<td>declare</td>
<td>depmod</td>
<td>dmesg               </td>
</tr>
<tr>
<td>enable</td>
<td>eval</td>
<td>export</td>
<td>pwunconv            </td>
</tr>
<tr>
<td>grpconv</td>
<td>rpm</td>
<td>insmod</td>
<td>kbdconfig           </td>
</tr>
<tr>
<td>lilo</td>
<td>liloconfig</td>
<td>lsmod</td>
<td>minfo               </td>
</tr>
<tr>
<td>set</td>
<td>modprobe</td>
<td>ntsysv</td>
<td>mouseconfig         </td>
</tr>
<tr>
<td>passwd</td>
<td>pwconv</td>
<td>rdate</td>
<td>resize              </td>
</tr>
<tr>
<td>rmmod</td>
<td>grpunconv</td>
<td>modinfo</td>
<td>time                </td>
</tr>
<tr>
<td>setup</td>
<td>sndconfig</td>
<td>setenv</td>
<td>setconsole          </td>
</tr>
<tr>
<td>timeconfig</td>
<td>ulimit</td>
<td>unset</td>
<td>chkconfig           </td>
</tr>
<tr>
<td>apmd</td>
<td>hwclock</td>
<td>mkkickstart</td>
<td>fbset               </td>
</tr>
<tr>
<td>unalias</td>
<td>SVGATextMode</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>备份压缩</strong></p>
<table>
<thead>
<tr>
<th>ar</th>
<th>bunzip2</th>
<th>bzip2</th>
<th>bzip2recover        </th>
</tr>
</thead>
<tbody>
<tr>
<td>gunzip</td>
<td>unarj</td>
<td>compress</td>
<td>cpio                </td>
</tr>
<tr>
<td>dump</td>
<td>uuencode</td>
<td>gzexe</td>
<td>gzip                </td>
</tr>
<tr>
<td>lha</td>
<td>restore</td>
<td>tar</td>
<td>uudecode            </td>
</tr>
<tr>
<td>unzip</td>
<td>zip</td>
<td>zipinfo</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>设备管理</strong></p>
<table>
<thead>
<tr>
<th>setleds</th>
<th>loadkeys</th>
<th>rdev</th>
<th>dumpkeys            </th>
</tr>
</thead>
<tbody>
<tr>
<td>MAKEDEV</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.helkay.me/2017/05/Git命令&quot;&gt;Git命令&lt;/a&gt;&lt;/li&gt;
&lt;/u
    
    </summary>
    
      <category term="Menu" scheme="http://blog.helkay.me/categories/Menu/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 注解 Annotations</title>
    <link href="http://blog.helkay.me/2017/05/Java%20%E6%B3%A8%E8%A7%A3%20Annotations/"/>
    <id>http://blog.helkay.me/2017/05/Java 注解 Annotations/</id>
    <published>2017-05-10T16:00:00.000Z</published>
    <updated>2017-05-12T07:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h3><p>  可理解为元数据，即一种描述数据的数据。</p>
<pre><code class="java">@Override
public String toString() {
    return &quot;toString...&quot;;
}
</code></pre>
<p>在上面的代码中我用Override重写了toString()代码,当然即使我不用注解,程序也是能够正常运行的,但加上了Override注解,它会告诉编译器这是个重写的方法,如果我不小心写错了方法名,而父类中没有该方法,则编译器就会报错。</p>
<h3 id="有关Annotation的一些说明"><a href="#有关Annotation的一些说明" class="headerlink" title="有关Annotation的一些说明"></a>有关Annotation的一些说明</h3><p>java8 版本在 java.lang.annotation提供了六种元注解(Native和Repeatable是java8加入的，其他的是java5),用来注解其他注解:</p>
<h4 id="Documented-一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。"><a href="#Documented-一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。" class="headerlink" title="@Documented    : 一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。"></a>@Documented    : 一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。</h4><h4 id="Retention-定义该注解的生命周期。"><a href="#Retention-定义该注解的生命周期。" class="headerlink" title="@Retention : 定义该注解的生命周期。"></a>@Retention : 定义该注解的生命周期。</h4><pre><code>    RetentionPolicy.SOURCE
    在编译阶段丢弃。

    RetentionPolicy.CLASS
    在类加载的时候丢弃。

    RetentionPolicy.RUNTIME
     始终不会丢弃，运行期也保留该注解。
</code></pre><h4 id="Target-表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。"><a href="#Target-表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。" class="headerlink" title="@Target : 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。"></a>@Target : 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。</h4><pre><code class="java">@Retention(RetentionPolicy.SOURCE)
@Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})
public @interface TestTarget {

}
</code></pre>
<p><strong>ElementType.TYPE:用于描述类、接口或enum声明</strong></p>
<pre><code class="java">@TestTarget
public interface Annotations {

}

@TestTarget
public class Annotations {

}

@TestTarget
public enum  Annotations {

}
</code></pre>
<p><strong>ElementType.FIELD:用于描述实例变量</strong></p>
<pre><code class="java">public class Annotations {

    @TestTarget public String name;

}
</code></pre>
<p><strong>ElementType.METHOD:用于描述方法</strong></p>
<pre><code class="java">public class Annotations {

    @TestTarget
    public void test(){

    }

}
</code></pre>
<p><strong>ElementType.PARAMETER:用于描述参数</strong></p>
<pre><code class="java">public class Annotations {

    public void test(@TestTarget String name){

    }

}
</code></pre>
<p><strong>ElementType.CONSTRUCTOR:用于描述构造方法</strong></p>
<pre><code class="java">public class Annotations {

    @TestTarget
    public Annotations() {
    }
}
</code></pre>
<p><strong>ElementType.LOCAL_VARIABLE:用于描述局部变量</strong></p>
<pre><code class="java">public class Annotations {

    public void test(){

        @TestTarget String name;

    }
}
</code></pre>
<p><strong>ElementType.ANNOTATION_TYPE:用于描述另一个注释</strong></p>
<pre><code class="java">public class Annotations {

    @TestTarget
    public @interface TestAnnotationType {

    }
}
</code></pre>
<p><strong>ElementType.PACKAGE 用于记录java文件的package信息</strong></p>
<pre><code class="java">@TestTarget
package com.helkay.common;
</code></pre>
<p>需要注意的一点是package注解只能写在package-info.java这个文件中</p>
<p><strong>since 1.8 加入</strong></p>
<p><strong>ElementType.TYPE_PARAMETER:用于描述类型参数</strong></p>
<pre><code class="java">public class Annotation&lt;@TestTarget T&gt; {

}
</code></pre>
<p><strong>ElementType.TYPE_USE:用于描述类型使用</strong></p>
<pre><code class="java">public class Annotation&lt;@TestTarget T&gt; {

    public List&lt;@TestTarget T&gt; test(@TestTarget String name){

        List&lt;@TestTarget T&gt; list1 = new ArrayList&lt;&gt;();

        List&lt;? extends T&gt; list2 = new ArrayList&lt;@TestTarget T&gt;();

        @TestTarget String text;

        text = (@TestTarget String)new Object();

        java.util. @TestTarget Scanner console;

        console = new java.util.@TestTarget Scanner(System.in);

        return new ArrayList&lt;@TestTarget T&gt;();
    }
}
</code></pre>
<h4 id="Inherited-定义该注释和子类的关系"><a href="#Inherited-定义该注释和子类的关系" class="headerlink" title="@Inherited : 定义该注释和子类的关系"></a>@Inherited : 定义该注释和子类的关系</h4><p><strong><em>Annotations只支持基本类型、String及枚举类型</em></strong></p>
<pre><code class="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@interface TestTarget {

    public enum Sex {MAN, WOMAN}

    String author() default &quot;Helkay&quot;;

    Sex sex () default Sex.MAN;
}
</code></pre>
<p><strong><em>如何使用:</em></strong></p>
<pre><code class="java">public class Annotation {

    @TestTarget( sex = TestTarget.Sex.WOMAN , author = &quot;Hiko&quot;)
    public void test(){

    }
}
</code></pre>
<p><strong><em>只有一个属性</em></strong></p>
<pre><code class="java">@interface TestTarget{
String value();
}

@ TestTarget(&quot;Helkay&quot;)
public void test() {
}
</code></pre>
<h4 id="Native-仅仅用来标记native的属性"><a href="#Native-仅仅用来标记native的属性" class="headerlink" title="@Native : 仅仅用来标记native的属性"></a>@Native : 仅仅用来标记native的属性</h4><h4 id="Repeatable-可重复注解的注解"><a href="#Repeatable-可重复注解的注解" class="headerlink" title="@Repeatable : 可重复注解的注解"></a>@Repeatable : 可重复注解的注解</h4><p><strong>不使用Repeatable</strong></p>
<pre><code class="java">public class Annotation {

    @interface TestTarget {
        String name();
    }

    @interface TestTargetArr {
        TestTarget[] value();
    }

    @TestTargetArr({@TestTarget(name = &quot;Helkay&quot;),@TestTarget(name = &quot;Hiko&quot;)})
    public void test(){

    }
}
</code></pre>
<p><strong>使用Repeatable</strong></p>
<pre><code class="java">public class Annotation {

    @Repeatable(TestTargetArr.class)
    @interface TestTarget {
        String name();
    }

    @interface TestTargetArr {
        TestTarget[] value();
    }

    @TestTarget(name = &quot;Helkay&quot;)
    @TestTarget(name = &quot;Hiko&quot;)
    public void test(){

    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是注解？&quot;&gt;&lt;a href=&quot;#什么是注解？&quot; class=&quot;headerlink&quot; title=&quot;什么是注解？&quot;&gt;&lt;/a&gt;什么是注解？&lt;/h3&gt;&lt;p&gt;  可理解为元数据，即一种描述数据的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Ove
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Java" scheme="http://blog.helkay.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Intellij idea 远程调试</title>
    <link href="http://blog.helkay.me/2017/05/Intellij%20Idea%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.helkay.me/2017/05/Intellij Idea远程调试/</id>
    <published>2017-05-09T16:00:00.000Z</published>
    <updated>2017-07-04T03:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="idea自带的remote"><a href="#idea自带的remote" class="headerlink" title="idea自带的remote"></a>idea自带的remote</h2><div align="center"><br><img src="http://blog.helkay.me/pic/idea1.png" style="width:700px;" alt="图片名称" align="center">
</div>


<h2 id="tomcat-remote-配置"><a href="#tomcat-remote-配置" class="headerlink" title="tomcat remote 配置"></a>tomcat remote 配置</h2><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><div align="center"><br><img src="http://blog.helkay.me/pic/idea2.png" style="width:700px;" alt="图片名称" align="center">
</div>

<h3 id="Startup-Connection"><a href="#Startup-Connection" class="headerlink" title="Startup/Connection"></a>Startup/Connection</h3><div align="center"><br><img src="http://blog.helkay.me/pic/idea3.png" style="width:700px;" alt="图片名称" align="center">
</div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;idea自带的remote&quot;&gt;&lt;a href=&quot;#idea自带的remote&quot; class=&quot;headerlink&quot; title=&quot;idea自带的remote&quot;&gt;&lt;/a&gt;idea自带的remote&lt;/h2&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img 
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="工具" scheme="http://blog.helkay.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ssh登录免密</title>
    <link href="http://blog.helkay.me/2017/05/ssh%E7%99%BB%E5%BD%95%E5%85%8D%E5%AF%86/"/>
    <id>http://blog.helkay.me/2017/05/ssh登录免密/</id>
    <published>2017-05-09T16:00:00.000Z</published>
    <updated>2017-05-12T07:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用ssh-keygen命令创建密钥对"><a href="#使用ssh-keygen命令创建密钥对" class="headerlink" title="使用ssh-keygen命令创建密钥对"></a>使用ssh-keygen命令创建密钥对</h3><p>假设 我现在需要在A机(192.168.1.1)上免密ssh登录到B(192.168.1.2)机</p>
<p>在A机用户路径中的.ssh文件夹内创建密钥对</p>
<pre><code class="bash">ssh-keygen -t rsa -f id_rsa.xxx  -P &#39;&#39;
</code></pre>
<ul>
<li>-f 命名生成的文件名称</li>
<li>-P ‘’  无密码 （不加则需要输入三次回车）</li>
</ul>
<p>这时候.ssh文件夹下会生成两个文件(id_rsa.xxx  id_rsa.xxx.pub)</p>
<p>将id_rsa.xxx.pub 用scp命令传输的B上</p>
<pre><code class="bash">scp id_rsa.xxx.pub root@192.168.1.2:/(B机上.ssh的路径)
</code></pre>
<p>将id_rsa.xxx.pub里的内容写入到 .ssh中的authorized_keys文件中(没有则创建),并修改authorized_keys文件和.ssh文件夹的权限</p>
<pre><code class="bash">cat id_rsa.xxx.pub&gt;&gt;authorized_keys

chmod 600 authorized_keys

chmod 700 -R .ssh
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用ssh-keygen命令创建密钥对&quot;&gt;&lt;a href=&quot;#使用ssh-keygen命令创建密钥对&quot; class=&quot;headerlink&quot; title=&quot;使用ssh-keygen命令创建密钥对&quot;&gt;&lt;/a&gt;使用ssh-keygen命令创建密钥对&lt;/h3&gt;&lt;p&gt;假设
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="Linux" scheme="http://blog.helkay.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://blog.helkay.me/2017/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.helkay.me/2017/05/抽象工厂模式/</id>
    <published>2017-05-05T16:00:00.000Z</published>
    <updated>2017-07-04T03:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>产品族:</strong> 位于不同产品等级结构中，功能相关联的产品组成的家族</p>
<p>图中GreenCar和RedCar是两个产品树,而GreenJeepCar和GreenSportCar就是一个产品族,他们都是属于Green色的车。同理RedJeepCar和RedSportCar也是一个产品族。</p>
<div align="center"><br><img src="http://blog.helkay.me/pic/abstract_factory_method.png" style="width:700px;" alt="图片名称" align="center">
</div>

<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p><strong>GreenCar</strong></p>
<pre><code class="java">public abstract class GreenCar {

    public abstract void getColorGreen();

}
</code></pre>
<p><strong>GreenJeepCar</strong></p>
<pre><code class="java">public class GreenJeepCar extends GreenCar {
    @Override
    public void getColorGreen() {
        System.out.println(&quot; Get Color Green &quot;);
    }
}
</code></pre>
<p><strong>GreenSportCar</strong></p>
<pre><code class="java">public class GreenSportCar extends GreenCar {
    @Override
    public void getColorGreen() {
        System.out.println(&quot; Get Color Green &quot;);
    }
}
</code></pre>
<p><strong>RedCar</strong></p>
<pre><code class="java">public abstract class RedCar {

    public abstract void getColorRed();

}
</code></pre>
<p><strong>RedJeepCar</strong></p>
<pre><code class="java">public class RedJeepCar extends RedCar {
    @Override
    public void getColorRed() {
        System.out.println(&quot; Get Color Red &quot;);
    }
}
</code></pre>
<p><strong>RedSportCar</strong></p>
<pre><code class="java">public class RedSportCar extends RedCar {
    @Override
    public void getColorRed() {
        System.out.println(&quot; Get Color Red &quot;);
    }
}
</code></pre>
<p><strong>IFactory</strong></p>
<pre><code class="java">public abstract class IFactory {

    public abstract RedCar createRedCar();

    public abstract GreenCar createGreenCar();

}
</code></pre>
<p><strong>JeepFactory</strong></p>
<pre><code class="java">public class JeepFactory extends IFactory {

    @Override
    public RedCar createRedCar() {
        System.out.println(&quot; Create Jeep Car &quot;);
        return new RedJeepCar();
    }

    @Override
    public GreenCar createGreenCar() {
        System.out.println(&quot; Create Jeep Car &quot;);
        return new GreenJeepCar();
    }
}
</code></pre>
<p><strong>SportFactory</strong></p>
<pre><code class="java">public class SportFactory extends IFactory {

    @Override
    public RedCar createRedCar() {
        System.out.println(&quot; Create Sport Car &quot;);
        return new RedSportCar();
    }

    @Override
    public GreenCar createGreenCar() {
        System.out.println(&quot; Create Sport Car &quot;);
        return new GreenSportCar();
    }
}
</code></pre>
<p><strong>Test</strong></p>
<pre><code class="java">public class Test {

    public static void main(String[] args) {
        IFactory sportFactory = new SportFactory();

        GreenCar greenCar = sportFactory.createGreenCar();

        greenCar.getColorGreen();

    }

}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象工厂模式&quot;&gt;&lt;a href=&quot;#抽象工厂模式&quot; class=&quot;headerlink&quot; title=&quot;抽象工厂模式&quot;&gt;&lt;/a&gt;抽象工厂模式&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="设计模式" scheme="http://blog.helkay.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="http://blog.helkay.me/2017/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.helkay.me/2017/05/工厂方法模式/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2017-07-04T03:38:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p>
<div align="center"><br><img src="http://blog.helkay.me/pic/simple_factory_method.png" style="width:700px;" alt="图片名称" align="center">
</div>

<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p><strong>ICar</strong></p>
<pre><code class="java">public interface ICar {

    void getCar();

}
</code></pre>
<p><strong>JeepCar</strong></p>
<pre><code class="java">public class JeepCar implements ICar {

    @Override
    public void getCar() {
        System.out.println(&quot;Get JeepCar ...&quot;);
    }

}
</code></pre>
<p><strong>SportCar</strong></p>
<pre><code class="java">public class SportCar implements ICar {

    @Override
    public void getCar() {
        System.out.println(&quot;Get SportCar ...&quot;);
    }

}
</code></pre>
<p><strong>Factory</strong></p>
<pre><code class="java">public class Factory {

    public ICar getInstance(String carType) throws IllegalAccessException, InstantiationException {

        if(&quot;sportCat&quot;.equals(carType)){
            return SportCar.class.newInstance();
        }else if(&quot;jeepCat&quot;.equals(carType)){
            return JeepCar.class.newInstance();
        }else{
            System.out.println(&quot;No object is instantiated&quot;);
            return null;
        }
    }


    public static void main(String[] args) {
        Factory factory = new Factory();
        try {
            factory.getInstance(&quot;sportCat&quot;).getCar();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>在上面的简单工厂模式中我们将实例化具体对象的工作全部交给了专门负责创建对象的工厂类中,而工厂模式中则让子类决定实例化哪一个类。遵循了开放—封闭原则</p>
<div align="center"><br><img src="http://blog.helkay.me/pic/factory_method.png" style="width:700px;" alt="图片名称" align="center">
</div>

<h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><p><strong>IFactory</strong></p>
<pre><code class="java">public interface IFactory {

    ICar createCar();

}
</code></pre>
<p><strong>JeepFactory</strong></p>
<pre><code class="java">public class JeepFactory implements IFactory {

    @Override
    public ICar createCar() {
        System.out.println(&quot;JeepCar create ...&quot;);
        return new JeepCar();
    }

}
</code></pre>
<p><strong>SportFactory</strong></p>
<pre><code class="java">public class SportFactory implements IFactory {

    @Override
    public ICar createCar() {
        System.out.println(&quot;SportCar create ...&quot;);
        return new SportCar();
    }

}
</code></pre>
<p><strong>ICar</strong></p>
<pre><code class="java">public interface ICar {

    void getCar();

}
</code></pre>
<p><strong>JeepCar</strong></p>
<pre><code class="java">public class JeepCar implements ICar {

    @Override
    public void getCar() {
        System.out.println(&quot;Get JeepCar ...&quot;);
    }

}
</code></pre>
<p><strong>SprotCar</strong></p>
<pre><code class="java">public class SportCar implements ICar {

    @Override
    public void getCar() {
        System.out.println(&quot;Get SportCar ...&quot;);
    }

}
</code></pre>
<p><strong>Test</strong></p>
<pre><code class="java">public class Test {

    public static void main(String[] args) {
        IFactory sportFactory = new SportFactory();

        ICar sportFactoryCar = sportFactory.createCar();

        sportFactoryCar.getCar();
    }

}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单工厂模式&quot;&gt;&lt;a href=&quot;#简单工厂模式&quot; class=&quot;headerlink&quot; title=&quot;简单工厂模式&quot;&gt;&lt;/a&gt;简单工厂模式&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="设计模式" scheme="http://blog.helkay.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://blog.helkay.me/2017/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://blog.helkay.me/2017/05/多线程/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2017-05-12T07:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写设计模式-单例模式的过程中,我需要本地模拟多线程高并发,所以就有了这个笔记。</p>
<p>名词解释：</p>
<ul>
<li>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程</li>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑,是真正的同时。</li>
<li>并发：通过cpu调度算法,让用户看上去同时执行,实际上从cpu操作层面不是真正的同时。</li>
</ul>
<p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><pre><code class="java">public class Thread1 extends Thread {

    public void run() {
        System.out.println(&quot;run start!&quot;);
    }

    public static void main(String[] args) {
        Thread1 t1 = new Thread1();
        Thread1 t2 = new Thread1();
        t1.start();
        t2.start();
    }
}
</code></pre>
<h2 id="实现Runnable类"><a href="#实现Runnable类" class="headerlink" title="实现Runnable类"></a>实现Runnable类</h2><pre><code class="java">public class Thread2 implements Runnable{

    @Override
    public void run() {
        System.out.println(&quot;run start!&quot;);
    }

    public static void main(String[] args) {
        Thread2 t1 = new Thread2();
        Thread2 t2 = new Thread2();

        Thread thread1 = new Thread(t1);
        Thread thread2 = new Thread(t2);

        thread1.start();
        thread2.start();

//        简写
//        new Thread(new Thread2()).start();
//        new Thread(new Thread2()).start();
    }
}
</code></pre>
<h2 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h2><p>对于这两个方法,首先得明确一点,sleep()方法是属于Thread类的,而wait()方法则是属于Object类的。</p>
<ul>
<li><strong><font color="#e25440">主程序中sleep()</font></strong></li>
</ul>
<pre><code class="java">public class ThreadTest {

    public static void main(String[] args) {

        ThreadDemo1 td1 = new ThreadDemo1();
        td1.start();

        try {
            Thread.sleep(3000); //主程序中休眠3s
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        ThreadDemo2 td2 = new ThreadDemo2();
        td2.start();
    }

    public static String getDate(){
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
        return sdf.format(new Date());
    }

}

class ThreadDemo1 extends Thread{
    public void run(){
        System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo1 start run...&quot;);
    }
}

class ThreadDemo2 extends Thread{
    public void run(){
        System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo2 start run...&quot;);
    }
}
</code></pre>
<p>结果：</p>
<pre><code class="java">15:48:25 -- ThreadDemo1 start run...
15:48:28 -- ThreadDemo2 start run...
</code></pre>
<ul>
<li><strong><font color="#e25440">线程中sleep()</font></strong></li>
</ul>
<pre><code class="java">public class ThreadTest {

    public static void main(String[] args) {

        ThreadDemo1 td1 = new ThreadDemo1();
        td1.start();

        ThreadDemo2 td2 = new ThreadDemo2();
        td2.start();
    }

    public static String getDate(){
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
        return sdf.format(new Date());
    }

}

class ThreadDemo1 extends Thread{
    public void run(){
        try {
            System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo1 start sleep...&quot;);
            Thread.sleep(3000);
            System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo1 start run...&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}

class ThreadDemo2 extends Thread{
    public void run(){
        synchronized (ThreadTest.class){
            System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo2 start run...&quot;);
        }
    }
}
</code></pre>
<p>结果：</p>
<pre><code class="java">15:57:52 -- ThreadDemo1 start sleep...
15:57:52 -- ThreadDemo2 start run...
15:57:55 -- ThreadDemo1 start run...
</code></pre>
<p><strong><em>sleep()导致的是程序暂停指定的时间,线程不会释放对象锁。</em></strong></p>
<ul>
<li><strong><font color="#e25440">wait()的测试Demo</font></strong></li>
</ul>
<pre><code class="java">public class ThreadTest {

    public static void main(String[] args) {

        ThreadDemo1 td1 = new ThreadDemo1();
        td1.start();

        ThreadDemo2 td2 = new ThreadDemo2();
        td2.start();
    }

    public static String getDate() {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
        return sdf.format(new Date());
    }

}

class ThreadDemo1 extends Thread {
    public void run() {
        synchronized (ThreadTest.class) {
            try {
                System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo1 start wait...&quot;);
                ThreadTest.class.wait();
                System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo1 start run...&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

class ThreadDemo2 extends Thread {
    public void run() {
        synchronized (ThreadTest.class) {
            System.out.println(ThreadTest.getDate() + &quot; -- ThreadDemo2 start run...&quot;);
            ThreadTest.class.notify();
        }

    }
}
</code></pre>
<p> 结果：</p>
<pre><code class="java">17:05:43 -- ThreadDemo1 start wait...
17:05:43 -- ThreadDemo2 start run...
17:05:43 -- ThreadDemo1 start run...
</code></pre>
<p><strong><em>ThreadDemo1 wait后将资源让给了 ThreadDemo2, ThreadDemo2执行完后唤醒了ThreadDemo1</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写设计模式-单例模式的过程中,我需要本地模拟多线程高并发,所以就有了这个笔记。&lt;/p&gt;
&lt;p&gt;名词解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程：指的是这个程序（一个进程）运行时产生了不止一个线程&lt;/li&gt;
&lt;li&gt;并行：多个cpu实例或者多台机器同时执行一段处理逻辑,是真正的
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="多线程" scheme="http://blog.helkay.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://blog.helkay.me/2017/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.helkay.me/2017/05/单例模式/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2017-05-12T07:00:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。"><a href="#单例模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。" class="headerlink" title="单例模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。"></a>单例模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。</h3><ul>
<li><strong><font color="#e25440" size="4">懒汉式(线程不安全)</font></strong></li>
</ul>
<pre><code class="java">public class SingletonDemoOne {

    private static SingletonDemoOne instance;

    private SingletonDemoOne() {
    }

    public static SingletonDemoOne getInstance() {
        if (instance == null) {
            instance = new SingletonDemoOne();
            //todo
        }
        return instance;
    }
}
</code></pre>
<p><strong><em>延迟加载很明显，但是在多线程不能正常工作</em></strong></p>
<ul>
<li><strong><font color="#e25440" size="4">懒汉式(线程安全)</font></strong></li>
</ul>
<pre><code class="java">public class SingletonDemoTwo {

    private static SingletonDemoTwo instance;

    private SingletonDemoTwo() {
    }

    public static synchronized SingletonDemoTwo getInstance() {
        if (instance == null) {
            instance = new SingletonDemoTwo();
            //todo
        }
        return instance;
    }
}
</code></pre>
<p><strong><em>延迟加载明显,但是效率很低</em></strong></p>
<ul>
<li><strong><font color="#e25440" size="4">饿汉式</font></strong></li>
</ul>
<pre><code class="java">public class SingletonDemoThree {
    private static SingletonDemoThree instance = new SingletonDemoThree();

    private SingletonDemoThree() {
    }

    public static SingletonDemoThree getInstance() {
        return instance;
    }
}
</code></pre>
<p><strong><em>在类加载的时候实例化,不能确定是否有其他方法导致类加载,且没有达到延迟加载效果</em></strong></p>
<ul>
<li><strong><font color="#e25440" size="4">双重检查[推荐使用]</font></strong></li>
</ul>
<pre><code class="java">public class SingletonDemoFour {

    private static volatile SingletonDemoFour singleton;

    private SingletonDemoFour() {
    }

    public static SingletonDemoFour getInstance() {
        if (singleton == null) {
            synchronized (SingletonDemoFour.class) {
                if (singleton == null) {
                    singleton = new SingletonDemoFour();
                }
            }
        }
        return singleton;
    }
}
</code></pre>
<p><strong><em>线程安全,延迟加载,效率较高。</em></strong></p>
<ul>
<li><strong><font color="#e25440" size="4">静态内部类[推荐使用]</font></strong></li>
</ul>
<pre><code class="java">public class SingletonDemoFive {

    private SingletonDemoFive() {
    }

    private static class SingletonInstance {
        private static final SingletonDemoFive INSTANCE = new SingletonDemoFive();
    }

    public static SingletonDemoFive getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
</code></pre>
<ul>
<li><strong><font color="#e25440" size="4">枚举[推荐使用]</font></strong></li>
</ul>
<pre><code class="java">public enum Singleton {
    INSTANCE;

    public void whateverMethod() {

    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单例模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。&quot;&gt;&lt;a href=&quot;#单例模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。&quot; class=&quot;headerlink&quot; title=&quot;单例模式主要作用是保证在Ja
    
    </summary>
    
      <category term="Blog" scheme="http://blog.helkay.me/categories/Blog/"/>
    
    
      <category term="设计模式" scheme="http://blog.helkay.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式目录</title>
    <link href="http://blog.helkay.me/menu/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%AE%E5%BD%95/"/>
    <id>http://blog.helkay.me/menu/设计模式目录/</id>
    <published>2017-04-30T16:00:00.000Z</published>
    <updated>2017-07-04T03:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ul>
<li><a href="http://blog.helkay.me/2017/05/工厂方法模式/">工厂方法模式</a></li>
<li><a href="http://blog.helkay.me/2017/05/抽象工厂模式/">抽象工厂模式</a></li>
<li><a href="http://blog.helkay.me/2017/05/单例模式/">单例模式</a></li>
<li><a href="http://blog.helkay.me/2017/05/建造者模式/">建造者模式</a></li>
<li><a href="http://blog.helkay.me/2017/05/原型模式/">原型模式</a></li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>并发型模式</li>
<li>线程池模式</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建型模式&quot;&gt;&lt;a href=&quot;#创建型模式&quot; class=&quot;headerlink&quot; title=&quot;创建型模式&quot;&gt;&lt;/a&gt;创建型模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.helkay.me/2017/05/工厂方法模式/&quot;&gt;工厂方法
    
    </summary>
    
      <category term="Menu" scheme="http://blog.helkay.me/categories/Menu/"/>
    
    
  </entry>
  
</feed>
